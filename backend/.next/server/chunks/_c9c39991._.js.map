{"version":3,"sources":["../../../../node_modules/base32.js/base32.js","../../../../node_modules/base32.js/index.js","../../../../node_modules/speakeasy/index.js","../../../../backend/src/lib/twofa.ts"],"sourcesContent":["\"use strict\";\n\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function (alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n}\n\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\n\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\n\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n */\n\nfunction Decoder (options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n\n/**\n * The default character map coresponds to RFC4648.\n */\n\nDecoder.prototype.charmap = rfc4648.charmap;\n\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry;\n\n  // decode string\n  str.toUpperCase().split(\"\").forEach(function (char) {\n\n    // ignore padding\n    if (char == \"=\") return;\n\n    // lookup symbol\n    var symbol = charmap[char] & 0xff;\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | (symbol >> -shift));\n      shift += 8;\n      carry = (symbol << shift) & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  });\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n */\n\nfunction Encoder (options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;\n    else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i;\n\n  // encode each byte in buf\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i];\n\n    // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | (byte >> shift);\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  }\n\n  // save state\n  this.shift = shift;\n  this.carry = carry;\n\n  // for chaining\n  return this;\n};\n\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n  return this.buf;\n};\n\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n};\n\n// Exports.\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\n","\"use strict\";\n\n// Module dependencies.\nvar base32 = require(\"./base32\");\n\n\n// Wrap decoder finalize to return a buffer;\nvar finalizeDecode = base32.Decoder.prototype.finalize;\nbase32.Decoder.prototype.finalize = function (buf) {\n  var bytes = finalizeDecode.call(this, buf);\n  return new Buffer(bytes);\n};\n\n\n// Export Base32.\nmodule.exports = base32;\n","'use strict';\n\nvar base32 = require('base32.js');\nvar crypto = require('crypto');\nvar url = require('url');\nvar util = require('util');\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest (options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    secret = encoding === 'base32' ? base32.decode(secret)\n      : new Buffer(secret, encoding);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate (options) {\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 |\n    (digest[offset + 1] & 0xff) << 16 |\n    (digest[offset + 2] & 0xff) << 8 |\n    (digest[offset + 3] & 0xff);\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp己erifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta (options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {delta: i - counter};\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp己erify\n * @global\n */\nexports.hotp.verify = function hotpVerify (options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter (options) {\n  var step = options.step || 30;\n  var time = options.time != null ? (options.time * 1000) : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp己erifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp己erify\n * @global\n */\nexports.totp.verify = function totpVerify (options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret (options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = encodeURIComponent(options.name || 'SecretKey');\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({ secret: SecretKey.base32, label: name }));\n  }\n\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII (length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL (options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = options.algorithm;\n  var digits = options.digits;\n  var period = options.period;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {secret: secret};\n  if (issuer) query.issuer = issuer;\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: label,\n    query: query\n  });\n};\n","/**\n * TOTP 2FA helpers using speakeasy. Secrets are base32.\n */\nimport speakeasy from 'speakeasy';\n\nconst ISSUER = process.env.TWOFA_ISSUER ?? 'Prospector';\n\nexport function generateTotpSecret(email: string): { secret: string; otpauthUrl: string } {\n  const secret = speakeasy.generateSecret({\n    name: `${ISSUER}:${email}`,\n    length: 20,\n  });\n  return {\n    secret: secret.base32,\n    otpauthUrl: secret.otpauth_url ?? `otpauth://totp/${ISSUER}:${email}?secret=${secret.base32}`,\n  };\n}\n\nexport function verifyTotpToken(secret: string, token: string): boolean {\n  return speakeasy.totp.verify({\n    secret,\n    encoding: 'base32',\n    token,\n    window: 1,\n  });\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2]}