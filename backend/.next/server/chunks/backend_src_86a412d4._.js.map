{"version":3,"sources":["../../../../backend/src/modules/search/application/search.service.ts","../../../../backend/src/lib/db-sync.ts","../../../../backend/src/lib/redis.ts","../../../../backend/src/lib/usage.ts","../../../../backend/src/lib/fetch-http.ts","../../../../backend/src/lib/google-places.ts","../../../../backend/src/lib/geocode.ts"],"sourcesContent":["/**\n * Search module — application layer (use-case).\n * Orchestrates cache, DB, external API, history and usage.\n * Route (api) only validates, authenticates and calls runSearch.\n */\n\nimport { prisma } from '@/lib/prisma';\nimport { textSearch, textSearchAllPages, PLACES_PAGE_SIZE_MAX } from '@/lib/google-places';\nimport { geocodeAddress } from '@/lib/geocode';\nimport { getCached } from '@/lib/redis';\nimport { syncLeads } from '@/lib/db-sync';\nimport { logger } from '@/lib/logger';\nimport { recordUsageEvent } from '@/lib/usage';\nimport type { SearchInput } from '@/lib/validations/schemas';\nimport type { SearchResult, PlaceLike } from '../domain/types';\n\n/** UI sempre em km; conversão para metros só na chamada à API (locationBias.radius). */\nconst RADIUS_KM_TO_M = 1000;\nconst DEFAULT_LOCATION_RADIUS_KM = 15;\n/** Places API locationBias circle max radius (meters) = 50km */\nconst MAX_LOCATION_RADIUS_M = 50000;\n/** Delay antes de usar nextPageToken (API pode rejeitar ou repetir se imediato). */\nconst NEXT_PAGE_TOKEN_DELAY_MS = 400;\n\nexport class SearchHttpError extends Error {\n    constructor(\n        public readonly status: number,\n        public readonly body: Record<string, unknown>\n    ) {\n        super(typeof body.error === 'string' ? body.error : 'Request failed');\n        this.name = 'SearchHttpError';\n    }\n}\n\nfunction filterPlaces<T extends PlaceLike>(\n    places: T[],\n    hasWebsite?: string | null,\n    hasPhone?: string | null\n): T[] {\n    return places.filter((place): place is T => {\n        const website = place.websiteUri || place.website;\n        const phone = place.nationalPhoneNumber || place.internationalPhoneNumber || place.phone;\n        if (hasWebsite === 'yes' && !website) return false;\n        if (hasWebsite === 'no' && website) return false;\n        if (hasPhone === 'yes' && !phone) return false;\n        if (hasPhone === 'no' && phone) return false;\n        return true;\n    });\n}\n\nexport async function runSearch(input: SearchInput, userId: string): Promise<SearchResult> {\n    const { textQuery, includedType, pageSize, pageToken, hasWebsite, hasPhone, city, state, country, radiusKm } = input;\n    const effectivePageSize = Math.min(PLACES_PAGE_SIZE_MAX, Math.max(1, pageSize ?? PLACES_PAGE_SIZE_MAX));\n    const filtersPayload = {\n        includedType: includedType ?? null,\n        hasWebsite: hasWebsite ?? null,\n        hasPhone: hasPhone ?? null,\n    };\n\n    logger.info('Search request', {\n        textQuery,\n        includedType: includedType ?? null,\n        effectivePageSize,\n        hasWebsite: hasWebsite ?? null,\n        hasPhone: hasPhone ?? null,\n    });\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n            onboardingCompletedAt: true,\n            workspaces: { include: { workspace: true }, take: 1 },\n        },\n    });\n\n    if (!user || user.workspaces.length === 0) {\n        throw new SearchHttpError(404, { error: 'Workspace not found' });\n    }\n\n    if (user.onboardingCompletedAt == null) {\n        throw new SearchHttpError(403, {\n            error: 'Complete onboarding before searching',\n            code: 'REQUIRES_ONBOARDING',\n        });\n    }\n\n    const activeWorkspace = user.workspaces[0].workspace;\n\n    if (activeWorkspace.leadsUsed >= activeWorkspace.leadsLimit) {\n        throw new SearchHttpError(403, {\n            error: 'Limit reached',\n            code: 'LIMIT_EXCEEDED',\n            limit: activeWorkspace.leadsLimit,\n            used: activeWorkspace.leadsUsed,\n        });\n    }\n\n    const saveHistory = async (resultsCount: number, places?: unknown[]): Promise<void> => {\n        await prisma.searchHistory\n            .create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectivePageSize,\n                    filters: filtersPayload,\n                    resultsCount,\n                    resultsData: places ? JSON.parse(JSON.stringify(places)) : undefined,\n                },\n            })\n            .catch((err) =>\n                logger.error('SearchHistory create error', {\n                    error: err instanceof Error ? err.message : 'Unknown',\n                })\n            );\n    };\n\n    if (!pageToken) {\n        const cacheKey = `search:${textQuery}:${includedType || ''}:${effectivePageSize}:${hasWebsite || 'any'}:${hasPhone || 'any'}`;\n        const cached = await getCached<{ places: unknown[]; nextPageToken?: string }>(cacheKey);\n        const cachedCount = cached?.places?.length ?? 0;\n        const minAcceptableFromCache = Math.min(5, effectivePageSize);\n        if (cachedCount >= minAcceptableFromCache) {\n            logger.info('Search: cache hit', { cachedCount });\n            await saveHistory(cachedCount, cached!.places);\n            return { ...cached!, fromCache: true };\n        }\n        if (cachedCount > 0) {\n            logger.info('Search: cache skipped (below minimum)', { cachedCount, minAcceptableFromCache });\n        }\n\n        const dbLeads = await prisma.lead.findMany({\n            where: {\n                OR: [\n                    { name: { contains: textQuery, mode: 'insensitive' } },\n                    { address: { contains: textQuery, mode: 'insensitive' } },\n                ],\n            },\n            take: 100,\n            orderBy: { lastSearchedAt: 'desc' },\n        });\n\n        if (dbLeads.length >= 10) {\n            const mapped = dbLeads.map((l) => ({\n                id: l.placeId,\n                displayName: { text: l.name },\n                formattedAddress: l.address,\n                nationalPhoneNumber: l.phone,\n                websiteUri: l.website,\n                rating: l.rating,\n                userRatingCount: l.reviewCount,\n                types: l.types,\n                businessStatus: l.businessStatus,\n            }));\n\n            const filtered = filterPlaces(mapped, hasWebsite, hasPhone);\n            const slice = filtered.slice(0, effectivePageSize);\n            if (slice.length >= 5) {\n                logger.info('Search: local DB used', { dbTotal: dbLeads.length, afterFilter: filtered.length, returned: slice.length });\n                await saveHistory(slice.length, slice);\n                return { places: slice, fromLocalDb: true };\n            }\n        }\n        logger.info('Search: local DB skip', { dbLeadsCount: dbLeads.length });\n    }\n\n    let locationBias: { center: { latitude: number; longitude: number }; radius: number } | undefined;\n    const cityTrim = city?.trim();\n    if (cityTrim && !pageToken) {\n        const coords = await geocodeAddress(cityTrim, state ?? null, country ?? 'Brasil');\n        if (coords) {\n            const radiusKmNum = radiusKm ?? DEFAULT_LOCATION_RADIUS_KM;\n            const radiusM = Math.min(\n                MAX_LOCATION_RADIUS_M,\n                Math.round(radiusKmNum * RADIUS_KM_TO_M) || Math.round(DEFAULT_LOCATION_RADIUS_KM * RADIUS_KM_TO_M)\n            );\n            locationBias = { center: coords, radius: radiusM };\n            logger.info('Search: locationBias applied', { city: cityTrim, radiusKm: radiusKmNum, radiusM });\n        } else {\n            logger.info('Search: geocode failed, no locationBias', { city: cityTrim });\n        }\n    }\n\n    if (pageToken) {\n        await new Promise((r) => setTimeout(r, NEXT_PAGE_TOKEN_DELAY_MS));\n    }\n\n    logger.info('Search: calling Google Places API', { textQuery, includedType: includedType ?? null, hasLocationBias: !!locationBias, hasPageToken: !!pageToken });\n    const result = await textSearch({\n        textQuery,\n        includedType: includedType || undefined,\n        pageSize: effectivePageSize,\n        pageToken: pageToken || undefined,\n        locationBias,\n    });\n\n    const rawCount = result.places?.length ?? 0;\n    if (result.places) {\n        result.places = filterPlaces(result.places, hasWebsite, hasPhone).slice(0, effectivePageSize);\n    }\n    const finalCount = result.places?.length ?? 0;\n    logger.info('Search: Google Places response', { rawCount, afterFilter: finalCount, hasWebsite: hasWebsite ?? null, hasPhone: hasPhone ?? null });\n\n    if (result.places && result.places.length > 0) {\n        recordUsageEvent({\n            workspaceId: activeWorkspace.id,\n            userId,\n            type: 'GOOGLE_PLACES_SEARCH',\n            quantity: 1,\n        });\n\n        syncLeads(result.places).catch((err) =>\n            logger.error('Background sync error', {\n                error: err instanceof Error ? err.message : 'Unknown',\n            })\n        );\n\n        await prisma.$transaction([\n            prisma.workspace.update({\n                where: { id: activeWorkspace.id },\n                data: { leadsUsed: { increment: 1 } },\n            }),\n            prisma.searchHistory.create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectivePageSize,\n                    filters: filtersPayload,\n                    resultsCount: result.places.length,\n                    resultsData: JSON.parse(JSON.stringify(result.places)),\n                },\n            }),\n        ]);\n    }\n\n    logger.info('Search: result', { resultCount: finalCount });\n    return result;\n}\n\n/** Max places to fetch in one runSearchAllPages call (intelligence modules). */\nexport const SEARCH_ALL_PAGES_MAX_PLACES = 60;\n\nexport interface SearchAllPagesResult {\n    places: unknown[];\n    totalFetched: number;\n}\n\n/**\n * Fetch multiple pages of search results (up to maxPlaces) for intelligence modules.\n * Uses a single usage credit regardless of how many API pages are fetched.\n */\nexport async function runSearchAllPages(\n    input: SearchInput,\n    userId: string,\n    maxPlaces: number\n): Promise<SearchAllPagesResult> {\n    const { textQuery, includedType, hasWebsite, hasPhone, city, state, country, radiusKm } = input;\n    const effectiveMax = Math.min(maxPlaces, SEARCH_ALL_PAGES_MAX_PLACES);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n            onboardingCompletedAt: true,\n            workspaces: { include: { workspace: true }, take: 1 },\n        },\n    });\n\n    if (!user || user.workspaces.length === 0) {\n        throw new SearchHttpError(404, { error: 'Workspace not found' });\n    }\n\n    if (user.onboardingCompletedAt == null) {\n        throw new SearchHttpError(403, {\n            error: 'Complete onboarding before searching',\n            code: 'REQUIRES_ONBOARDING',\n        });\n    }\n\n    const activeWorkspace = user.workspaces[0].workspace;\n\n    if (activeWorkspace.leadsUsed >= activeWorkspace.leadsLimit) {\n        throw new SearchHttpError(403, {\n            error: 'Limit reached',\n            code: 'LIMIT_EXCEEDED',\n            limit: activeWorkspace.leadsLimit,\n            used: activeWorkspace.leadsUsed,\n        });\n    }\n\n    let locationBias: { center: { latitude: number; longitude: number }; radius: number } | undefined;\n    const cityTrim = city?.trim();\n    if (cityTrim) {\n        const coords = await geocodeAddress(cityTrim, state ?? null, country ?? 'Brasil');\n        if (coords) {\n            const radiusKmNum = radiusKm ?? DEFAULT_LOCATION_RADIUS_KM;\n            const radiusM = Math.min(\n                MAX_LOCATION_RADIUS_M,\n                Math.round(radiusKmNum * RADIUS_KM_TO_M) || Math.round(DEFAULT_LOCATION_RADIUS_KM * RADIUS_KM_TO_M)\n            );\n            locationBias = { center: coords, radius: radiusM };\n            logger.info('SearchAllPages: locationBias applied', { city: cityTrim, radiusM });\n        }\n    }\n\n    logger.info('SearchAllPages: fetching up to N places', { textQuery, effectiveMax });\n    const { places: rawPlaces } = await textSearchAllPages({\n        textQuery,\n        includedType: includedType || undefined,\n        locationBias,\n        maxPlaces: effectiveMax,\n    });\n\n    const places = filterPlaces(rawPlaces, hasWebsite, hasPhone).slice(0, effectiveMax);\n    const totalFetched = places.length;\n\n    if (places.length > 0) {\n        recordUsageEvent({\n            workspaceId: activeWorkspace.id,\n            userId,\n            type: 'GOOGLE_PLACES_SEARCH',\n            quantity: 1,\n        });\n\n        syncLeads(places).catch((err) =>\n            logger.error('Background sync error', {\n                error: err instanceof Error ? err.message : 'Unknown',\n            })\n        );\n\n        const filtersPayload = {\n            includedType: includedType ?? null,\n            hasWebsite: hasWebsite ?? null,\n            hasPhone: hasPhone ?? null,\n        };\n\n        await prisma.$transaction([\n            prisma.workspace.update({\n                where: { id: activeWorkspace.id },\n                data: { leadsUsed: { increment: 1 } },\n            }),\n            prisma.searchHistory.create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectiveMax,\n                    filters: filtersPayload,\n                    resultsCount: totalFetched,\n                    resultsData: JSON.parse(JSON.stringify(places)),\n                },\n            }),\n        ]);\n    }\n\n    logger.info('SearchAllPages: result', { totalFetched });\n    return { places, totalFetched };\n}\n","import { prisma } from './prisma';\nimport { PlaceResult } from './google-places';\n\nexport async function syncLead(place: PlaceResult) {\n    try {\n        return await prisma.lead.upsert({\n            where: { placeId: place.id },\n            update: {\n                name: place.displayName.text,\n                address: place.formattedAddress,\n                phone: place.nationalPhoneNumber || place.internationalPhoneNumber,\n                website: place.websiteUri,\n                rating: place.rating,\n                reviewCount: place.userRatingCount,\n                types: place.types || [],\n                businessStatus: place.businessStatus,\n                lastSearchedAt: new Date(),\n            },\n            create: {\n                placeId: place.id,\n                name: place.displayName.text,\n                address: place.formattedAddress,\n                phone: place.nationalPhoneNumber || place.internationalPhoneNumber,\n                website: place.websiteUri,\n                rating: place.rating,\n                reviewCount: place.userRatingCount,\n                types: place.types || [],\n                businessStatus: place.businessStatus,\n            },\n        });\n    } catch (error) {\n        const { logger } = await import('@/lib/logger');\n        logger.error('Error syncing lead', { placeId: place.id, error: error instanceof Error ? error.message : 'Unknown' });\n        return null;\n    }\n}\n\nexport async function syncLeads(places: PlaceResult[]) {\n    return Promise.all(places.map(syncLead));\n}\n","import Redis from 'ioredis';\n\nlet redis: Redis | null = null;\n\nfunction getRedis(): Redis | null {\n    if (redis) return redis;\n    const url = process.env.REDIS_URL || 'redis://localhost:6379';\n    try {\n        redis = new Redis(url, {\n            maxRetriesPerRequest: 1,\n            retryStrategy: (times) => {\n                if (times > 2) return null;\n                return Math.min(times * 200, 1000);\n            },\n            lazyConnect: true,\n        });\n        redis.on('error', () => {\n            redis = null;\n        });\n        return redis;\n    } catch {\n        return null;\n    }\n}\n\nexport async function getCached<T>(key: string): Promise<T | null> {\n    try {\n        const client = getRedis();\n        if (!client) return null;\n        await client.connect().catch(() => { });\n        const data = await client.get(key);\n        if (!data) return null;\n        return JSON.parse(data) as T;\n    } catch {\n        return null;\n    }\n}\n\nexport async function setCached(key: string, value: unknown, ttlSeconds = 300): Promise<void> {\n    try {\n        const client = getRedis();\n        if (!client) return;\n        await client.connect().catch(() => { });\n        await client.set(key, JSON.stringify(value), 'EX', ttlSeconds);\n    } catch {\n        // silently fail — cache is optional\n    }\n}\n","/**\n * Usage event recording for admin dashboard metrics.\n * Fire-and-forget: does not block the request; errors are logged only.\n */\n\nimport { prisma } from '@/lib/prisma';\nimport type { UsageEventType } from '@prisma/client';\n\nexport interface RecordUsageOptions {\n  workspaceId: string;\n  userId?: string | null;\n  type: UsageEventType;\n  quantity?: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface WorkspaceUsage {\n  googlePlacesSearch: number;\n  googlePlacesDetails: number;\n  serperRequests: number;\n  aiInputTokens: number;\n  aiOutputTokens: number;\n}\n\n/**\n * Record a usage event (Google Places, Serper, AI tokens).\n * Runs in background; does not throw.\n */\nexport function recordUsageEvent(options: RecordUsageOptions): void {\n  const { workspaceId, userId, type, quantity = 1, metadata } = options;\n  void prisma.usageEvent\n    .create({\n      data: {\n        workspaceId,\n        userId: userId ?? undefined,\n        type,\n        quantity,\n        metadata: metadata ? (metadata as object) : undefined,\n      },\n    })\n    .catch((err) => {\n      import('@/lib/logger').then(({ logger }) =>\n        logger.warn('Usage event record failed', { workspaceId, type, error: err instanceof Error ? err.message : 'Unknown' })\n      );\n    });\n}\n\n/**\n * Get aggregated usage for one or more workspaces.\n */\nexport async function getWorkspaceUsage(workspaceIds: string[]): Promise<Map<string, WorkspaceUsage>> {\n  if (workspaceIds.length === 0) return new Map();\n  const defaultUsage: WorkspaceUsage = {\n    googlePlacesSearch: 0,\n    googlePlacesDetails: 0,\n    serperRequests: 0,\n    aiInputTokens: 0,\n    aiOutputTokens: 0,\n  };\n  const map = new Map<string, WorkspaceUsage>(workspaceIds.map((id) => [id, { ...defaultUsage }]));\n\n  const nonAi = await prisma.usageEvent.groupBy({\n    by: ['workspaceId', 'type'],\n    where: { workspaceId: { in: workspaceIds }, type: { not: 'AI_TOKENS' } },\n    _sum: { quantity: true },\n  });\n  for (const row of nonAi) {\n    const u = map.get(row.workspaceId)!;\n    const sum = row._sum.quantity ?? 0;\n    if (row.type === 'GOOGLE_PLACES_SEARCH') u.googlePlacesSearch = sum;\n    else if (row.type === 'GOOGLE_PLACES_DETAILS') u.googlePlacesDetails = sum;\n    else if (row.type === 'SERPER_REQUEST') u.serperRequests = sum;\n  }\n\n  const aiEvents = await prisma.usageEvent.findMany({\n    where: { workspaceId: { in: workspaceIds }, type: 'AI_TOKENS' },\n    select: { workspaceId: true, metadata: true },\n  });\n  for (const e of aiEvents) {\n    const u = map.get(e.workspaceId)!;\n    const m = e.metadata as { inputTokens?: number; outputTokens?: number } | null;\n    if (m) {\n      u.aiInputTokens += Number(m.inputTokens) || 0;\n      u.aiOutputTokens += Number(m.outputTokens) || 0;\n    }\n  }\n  return map;\n}\n","/**\n * HTTP fetch with timeout and optional retry on 429/5xx.\n * Evita requisições travadas e trata rate limit/erros transitórios.\n */\n\nconst DEFAULT_TIMEOUT_MS = 15000;\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_INITIAL_BACKOFF_MS = 1000;\n\nfunction sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface FetchWithRetryOptions {\n    timeoutMs?: number;\n    maxRetries?: number;\n    initialBackoffMs?: number;\n    /** Retry when response status is in this set (e.g. 429, 503). */\n    retryStatuses?: (status: number) => boolean;\n}\n\nconst defaultRetryStatuses = (status: number): boolean =>\n    status === 429 || (status >= 500 && status < 600);\n\n/**\n * Fetch with timeout (AbortController). Optional retry with exponential backoff on 429/5xx.\n */\nexport async function fetchWithRetry(\n    url: string,\n    init: RequestInit,\n    options: FetchWithRetryOptions = {}\n): Promise<Response> {\n    const {\n        timeoutMs = DEFAULT_TIMEOUT_MS,\n        maxRetries = DEFAULT_MAX_RETRIES,\n        initialBackoffMs = DEFAULT_INITIAL_BACKOFF_MS,\n        retryStatuses = defaultRetryStatuses,\n    } = options;\n\n    let lastRes: Response | null = null;\n    let lastErr: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n        const mergedInit: RequestInit = {\n            ...init,\n            signal: controller.signal,\n        };\n\n        try {\n            const res = await fetch(url, mergedInit);\n            clearTimeout(timeoutId);\n            lastRes = res;\n            if (attempt < maxRetries && retryStatuses(res.status)) {\n                const backoff = initialBackoffMs * Math.pow(2, attempt);\n                await sleep(backoff);\n                continue;\n            }\n            return res;\n        } catch (err) {\n            clearTimeout(timeoutId);\n            lastErr = err instanceof Error ? err : new Error(String(err));\n            if (attempt < maxRetries) {\n                const backoff = initialBackoffMs * Math.pow(2, attempt);\n                await sleep(backoff);\n                continue;\n            }\n            throw lastErr;\n        }\n    }\n\n    if (lastRes) return lastRes;\n    throw lastErr ?? new Error('fetchWithRetry failed');\n}\n","import { fetchWithRetry } from '@/lib/fetch-http';\n\nconst PLACES_API_BASE = 'https://places.googleapis.com/v1/places';\n\n/** Places API searchText max pageSize (doc: values above 20 are set to 20). */\nexport const PLACES_PAGE_SIZE_MAX = 20;\nconst PLACES_REQUEST_TIMEOUT_MS = 15000;\n/** Delay before using nextPageToken (API may reject or repeat if immediate). */\nconst NEXT_PAGE_TOKEN_DELAY_MS = 400;\n\nexport interface PlaceResult {\n    id: string;\n    displayName: { text: string; languageCode: string };\n    formattedAddress?: string;\n    nationalPhoneNumber?: string;\n    internationalPhoneNumber?: string;\n    websiteUri?: string;\n    googleMapsUri?: string;\n    rating?: number;\n    userRatingCount?: number;\n    types?: string[];\n    businessStatus?: string;\n    currentOpeningHours?: {\n        openNow?: boolean;\n        weekdayDescriptions?: string[];\n    };\n    reviews?: Array<{\n        name: string;\n        rating: number;\n        text: { text: string };\n        authorAttribution: { displayName: string };\n        relativePublishTimeDescription: string;\n    }>;\n    primaryType?: string;\n    primaryTypeDisplayName?: { text: string };\n}\n\nexport interface TextSearchResponse {\n    places: PlaceResult[];\n    nextPageToken?: string;\n}\n\n/** locationBias circle: center = cidade (geocodificada), radius = raio a partir da cidade. API exige radius em metros (max 50000). UI usa km. */\nexport interface LocationBiasCircle {\n    center: { latitude: number; longitude: number };\n    /** Raio em metros (UI envia km; converter antes de chamar a API). */\n    radius: number;\n}\n\nexport interface TextSearchParams {\n    textQuery: string;\n    includedType?: string;\n    pageSize?: number;\n    pageToken?: string;\n    languageCode?: string;\n    regionCode?: string;\n    /** Bias results to this region (Places API doc: locationBias.circle). */\n    locationBias?: LocationBiasCircle;\n}\n\nconst SEARCH_FIELD_MASK = [\n    'places.id',\n    'places.displayName',\n    'places.formattedAddress',\n    'places.nationalPhoneNumber',\n    'places.internationalPhoneNumber',\n    'places.websiteUri',\n    'places.googleMapsUri',\n    'places.rating',\n    'places.userRatingCount',\n    'places.types',\n    'places.businessStatus',\n    'places.primaryType',\n    'places.primaryTypeDisplayName',\n    'nextPageToken',\n].join(',');\n\nconst DETAILS_FIELD_MASK = [\n    'id',\n    'displayName',\n    'formattedAddress',\n    'nationalPhoneNumber',\n    'internationalPhoneNumber',\n    'websiteUri',\n    'googleMapsUri',\n    'rating',\n    'userRatingCount',\n    'types',\n    'businessStatus',\n    'currentOpeningHours',\n    'reviews',\n    'primaryType',\n    'primaryTypeDisplayName',\n].join(',');\n\n/**\n * In-memory cache of original request bodies keyed by nextPageToken.\n * Google Places API requires pagination requests to use identical params.\n * We store the original body (without pageToken) so we can replay it exactly.\n * TTL: entries auto-expire after 10 minutes via a simple cleanup.\n */\nconst pageTokenBodyCache = new Map<string, { body: Record<string, unknown>; ts: number }>();\nconst PAGE_TOKEN_CACHE_TTL_MS = 10 * 60 * 1000;\n\nfunction cleanupPageTokenCache() {\n    const now = Date.now();\n    for (const [key, val] of pageTokenBodyCache) {\n        if (now - val.ts > PAGE_TOKEN_CACHE_TTL_MS) pageTokenBodyCache.delete(key);\n    }\n}\n\nexport async function textSearch(params: TextSearchParams): Promise<TextSearchResponse> {\n    const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n    if (!apiKey) throw new Error('GOOGLE_PLACES_API_KEY not configured');\n\n    const pageSizeClamped = Math.min(\n        PLACES_PAGE_SIZE_MAX,\n        Math.max(1, params.pageSize ?? PLACES_PAGE_SIZE_MAX)\n    );\n\n    let body: Record<string, unknown>;\n\n    if (params.pageToken) {\n        // Pagination: replay the EXACT original body + pageToken\n        const cached = pageTokenBodyCache.get(params.pageToken);\n        if (cached) {\n            body = { ...cached.body, pageToken: params.pageToken };\n        } else {\n            // Fallback: build body with only textQuery + pageToken (no extra filters)\n            body = {\n                textQuery: params.textQuery,\n                pageSize: pageSizeClamped,\n                languageCode: params.languageCode || 'pt-BR',\n                regionCode: params.regionCode || 'BR',\n                pageToken: params.pageToken,\n            };\n        }\n    } else {\n        // Initial request: build full body with all filters\n        body = {\n            textQuery: params.textQuery,\n            pageSize: pageSizeClamped,\n            languageCode: params.languageCode || 'pt-BR',\n            regionCode: params.regionCode || 'BR',\n        };\n        if (params.includedType) body.includedType = params.includedType;\n        if (params.locationBias?.center && params.locationBias?.radius != null) {\n            const radius = Math.min(50000, Math.max(0, params.locationBias.radius));\n            body.locationBias = {\n                circle: {\n                    center: {\n                        latitude: params.locationBias.center.latitude,\n                        longitude: params.locationBias.center.longitude,\n                    },\n                    radius,\n                },\n            };\n        }\n    }\n\n    const res = await fetchWithRetry(\n        `${PLACES_API_BASE}:searchText`,\n        {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Goog-Api-Key': apiKey,\n                'X-Goog-FieldMask': SEARCH_FIELD_MASK,\n            },\n            body: JSON.stringify(body),\n        },\n        { timeoutMs: PLACES_REQUEST_TIMEOUT_MS, maxRetries: 3 }\n    );\n\n    if (!res.ok) {\n        const err = await res.text();\n        throw new Error(`Places API error (${res.status}): ${err}`);\n    }\n\n    const data = await res.json();\n\n    // Cache the original body (without pageToken) for future pagination\n    if (data.nextPageToken) {\n        const bodyWithoutToken = { ...body };\n        delete bodyWithoutToken.pageToken;\n        pageTokenBodyCache.set(data.nextPageToken, { body: bodyWithoutToken, ts: Date.now() });\n        // Periodic cleanup\n        if (pageTokenBodyCache.size > 50) cleanupPageTokenCache();\n    }\n\n    return {\n        places: data.places || [],\n        nextPageToken: data.nextPageToken,\n    };\n}\n\n/** Fetch multiple pages of search results up to maxPlaces (Places API returns max 20 per page). */\nexport async function textSearchAllPages(\n    params: TextSearchParams & { maxPlaces: number }\n): Promise<{ places: PlaceResult[] }> {\n    const { maxPlaces, ...searchParams } = params;\n    const cap = Math.max(1, Math.min(maxPlaces, 60));\n    const all: PlaceResult[] = [];\n    let pageToken: string | undefined;\n\n    while (all.length < cap) {\n        const res = await textSearch({\n            ...searchParams,\n            pageSize: Math.min(PLACES_PAGE_SIZE_MAX, cap - all.length),\n            pageToken,\n            // locationBias only on first page; subsequent pages use pageToken\n            locationBias: pageToken ? undefined : searchParams.locationBias,\n        });\n        const batch = res.places ?? [];\n        all.push(...batch);\n        if (batch.length === 0 || !res.nextPageToken) break;\n        if (all.length >= cap) break;\n        pageToken = res.nextPageToken;\n        await new Promise((r) => setTimeout(r, NEXT_PAGE_TOKEN_DELAY_MS));\n    }\n\n    return { places: all.slice(0, cap) };\n}\n\nexport async function getPlaceDetails(placeId: string): Promise<PlaceResult> {\n    const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n    if (!apiKey) throw new Error('GOOGLE_PLACES_API_KEY not configured');\n\n    const res = await fetchWithRetry(\n        `${PLACES_API_BASE}/${placeId}`,\n        {\n            method: 'GET',\n            headers: {\n                'X-Goog-Api-Key': apiKey,\n                'X-Goog-FieldMask': DETAILS_FIELD_MASK,\n            },\n        },\n        { timeoutMs: PLACES_REQUEST_TIMEOUT_MS, maxRetries: 2 }\n    );\n\n    if (!res.ok) {\n        const err = await res.text();\n        throw new Error(`Place Details error (${res.status}): ${err}`);\n    }\n\n    return await res.json();\n}\n","/**\n * Geocoding via Google Geocoding API.\n * Resolves city/state/country to lat/lng for Places API locationBias.\n * Center = cidade; raio (escolhido no UI em km) é aplicado a partir desse centro.\n * Uses GOOGLE_PLACES_API_KEY (same key can have Geocoding API enabled).\n */\n\nimport { fetchWithRetry } from '@/lib/fetch-http';\n\nconst GEOCODE_BASE = 'https://maps.googleapis.com/maps/api/geocode/json';\nconst GEOCODE_TIMEOUT_MS = 10000;\n\n/** Map country name/label to Google Geocoding API region code (biasing). */\nfunction getRegionCodeForCountry(country: string): string {\n  const normalized = country.trim().toLowerCase();\n  if (normalized.includes('brasil') || normalized === 'br') return 'br';\n  if (normalized.includes('argentina') || normalized === 'ar') return 'ar';\n  if (normalized.includes('méxico') || normalized.includes('mexico') || normalized === 'mx') return 'mx';\n  if (normalized.includes('estados unidos') || normalized.includes('united states') || normalized === 'us') return 'us';\n  if (normalized.includes('portugal') || normalized === 'pt') return 'pt';\n  if (normalized.includes('espanha') || normalized.includes('spain') || normalized === 'es') return 'es';\n  return 'br';\n}\n\nexport interface GeocodeResult {\n  latitude: number;\n  longitude: number;\n}\n\nexport async function geocodeAddress(\n  city: string,\n  state?: string | null,\n  country = 'Brasil'\n): Promise<GeocodeResult | null> {\n  const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n  if (!apiKey) return null;\n\n  const parts = [city.trim()];\n  if (state?.trim()) parts.push(state.trim());\n  parts.push(country);\n  const address = parts.join(', ');\n\n  const regionCode = getRegionCodeForCountry(country);\n  const url = new URL(GEOCODE_BASE);\n  url.searchParams.set('address', address);\n  url.searchParams.set('key', apiKey);\n  url.searchParams.set('region', regionCode);\n  url.searchParams.set('language', 'pt-BR');\n\n  const res = await fetchWithRetry(url.toString(), { method: 'GET' }, {\n    timeoutMs: GEOCODE_TIMEOUT_MS,\n    maxRetries: 2,\n  });\n  if (!res.ok) return null;\n  const data = (await res.json()) as {\n    status?: string;\n    results?: Array<{ geometry?: { location?: { lat?: number; lng?: number } } }>;\n  };\n  if (data.status !== 'OK' || !data.results?.[0]?.geometry?.location) return null;\n  const loc = data.results[0].geometry.location;\n  const lat = loc.lat;\n  const lng = loc.lng;\n  if (typeof lat !== 'number' || typeof lng !== 'number') return null;\n  return { latitude: lat, longitude: lng };\n}\n"],"names":[],"mappings":"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"}