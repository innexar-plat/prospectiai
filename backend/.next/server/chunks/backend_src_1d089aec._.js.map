{"version":3,"sources":["../../../../backend/src/modules/scoring/application/score.service.ts","../../../../backend/src/lib/ai/resolve.ts","../../../../backend/src/lib/web-search/serper.ts","../../../../backend/src/lib/web-search/resolve.ts","../../../../backend/src/lib/geocode.ts","../../../../backend/src/lib/product-modules.ts","../../../../backend/src/lib/db-sync.ts","../../../../backend/src/lib/redis.ts","../../../../backend/src/lib/usage.ts","../../../../backend/src/lib/fetch-http.ts","../../../../backend/src/lib/google-places.ts","../../../../backend/src/modules/search/application/search.service.ts"],"sourcesContent":["/**\n * Scoring module ‚Äî unified Opportunity Score engine (0‚Äì100).\n * Reused by Competitors, Market and Viability modules.\n *\n * Higher score = easier to close / bigger opportunity for the user.\n */\n\nimport type { ScoreFactors, ScoredPlace } from '../domain/types';\n\n/** Weights for each scoring factor (must sum to ~100 max). */\nconst WEIGHTS = {\n    noWebsite: 25,\n    noPhone: 15,\n    lowRating: 15,\n    fewReviews: 20,\n    lowReviewsVsMedian: 10,\n    mobilePhoneAvailable: 5,\n    operational: 5,\n    // reserved for future: missingPhotos: 5\n};\n\nconst LOW_RATING_THRESHOLD = 3.5;\nconst FEW_REVIEWS_THRESHOLD = 10;\n\n/** Brazilian mobile phone pattern: +55 XX 9xxxx-xxxx or (XX) 9xxxx-xxxx */\nconst BR_MOBILE_RE = /(?:\\+55\\s*)?(?:\\(?\\d{2}\\)?\\s*)?9\\d{4}[\\s-]?\\d{4}/;\n\nexport interface PlaceLikeForScoring {\n    id?: string;\n    name?: string;\n    displayName?: { text?: string };\n    formattedAddress?: string;\n    websiteUri?: string;\n    website?: string;\n    nationalPhoneNumber?: string;\n    internationalPhoneNumber?: string;\n    phone?: string;\n    rating?: number;\n    userRatingCount?: number;\n    reviewCount?: number;\n    primaryType?: string;\n    types?: string[];\n    businessStatus?: string;\n}\n\nfunction getPhone(p: PlaceLikeForScoring): string {\n    return (p.nationalPhoneNumber || p.internationalPhoneNumber || p.phone || '').trim();\n}\n\nfunction getWebsite(p: PlaceLikeForScoring): string {\n    return (p.websiteUri || p.website || '').trim();\n}\n\nfunction getReviewCount(p: PlaceLikeForScoring): number {\n    return p.userRatingCount ?? p.reviewCount ?? 0;\n}\n\nfunction getName(p: PlaceLikeForScoring): string {\n    return (p.displayName?.text || p.name || '').trim();\n}\n\n/**\n * Compute score factors for a single place.\n * @param medianReviews - median review count of the top competitors (for relative comparison)\n */\nexport function computeFactors(place: PlaceLikeForScoring, medianReviews = 0): ScoreFactors {\n    const website = getWebsite(place);\n    const phone = getPhone(place);\n    const rating = place.rating ?? 0;\n    const reviews = getReviewCount(place);\n\n    return {\n        noWebsite: !website,\n        noPhone: !phone,\n        lowRating: rating > 0 && rating < LOW_RATING_THRESHOLD,\n        fewReviews: reviews < FEW_REVIEWS_THRESHOLD,\n        lowReviewsVsMedian: medianReviews > 0 && reviews < medianReviews * 0.3,\n        mobilePhoneAvailable: BR_MOBILE_RE.test(phone),\n        operational: (place.businessStatus ?? 'OPERATIONAL') === 'OPERATIONAL',\n    };\n}\n\n/** Compute a 0‚Äì100 opportunity score from factors. */\nexport function computeScore(factors: ScoreFactors): number {\n    let score = 0;\n    if (factors.noWebsite) score += WEIGHTS.noWebsite;\n    if (factors.noPhone) score += WEIGHTS.noPhone;\n    if (factors.lowRating) score += WEIGHTS.lowRating;\n    if (factors.fewReviews) score += WEIGHTS.fewReviews;\n    if (factors.lowReviewsVsMedian) score += WEIGHTS.lowReviewsVsMedian;\n    if (factors.mobilePhoneAvailable) score += WEIGHTS.mobilePhoneAvailable;\n    if (factors.operational) score += WEIGHTS.operational;\n    return Math.min(100, Math.max(0, score));\n}\n\n/**\n * Score an array of places and return them sorted by score (highest first).\n * @param places raw place objects (from Google Places or local DB)\n * @param topN   max number of scored places to return (default: 20)\n */\nexport function scoreAndRankPlaces(\n    places: PlaceLikeForScoring[],\n    topN = 20\n): { scored: ScoredPlace[]; medianReviews: number; avgRating: number | null } {\n    // Compute median of top 10 review counts for relative comparison\n    const reviewCounts = places\n        .map((p) => getReviewCount(p))\n        .filter((c) => c > 0)\n        .sort((a, b) => b - a);\n    const top10Reviews = reviewCounts.slice(0, 10);\n    const medianReviews =\n        top10Reviews.length > 0\n            ? top10Reviews[Math.floor(top10Reviews.length / 2)]\n            : 0;\n\n    // Compute avg rating\n    const ratings = places.map((p) => p.rating).filter((r): r is number => r != null && r > 0);\n    const avgRating = ratings.length > 0 ? Math.round((ratings.reduce((a, b) => a + b, 0) / ratings.length) * 10) / 10 : null;\n\n    // Score all places\n    const scored: ScoredPlace[] = places\n        .map((p) => {\n            const factors = computeFactors(p, medianReviews);\n            return {\n                id: String(p.id ?? ''),\n                name: getName(p),\n                score: computeScore(factors),\n                scoreFactors: factors,\n                formattedAddress: p.formattedAddress,\n                phone: getPhone(p) || undefined,\n                website: getWebsite(p) || undefined,\n                rating: p.rating ?? undefined,\n                reviewCount: getReviewCount(p) || undefined,\n                primaryType: p.primaryType ?? (Array.isArray(p.types) ? p.types[0] : undefined),\n            };\n        })\n        .filter((p) => p.id && p.name)\n        .sort((a, b) => b.score - a.score)\n        .slice(0, topN);\n\n    return { scored, medianReviews, avgRating };\n}\n","/**\n * Resolves AI config by role: DB first, then env fallback (GEMINI_API_KEY).\n */\nimport { createGeminiAdapter } from './adapters/gemini';\nimport { createOpenAIAdapter } from './adapters/openai';\nimport { createCloudflareAdapter } from './adapters/cloudflare';\nimport type { AiRole, AiProviderType, CompletionOptions, CompletionResult, IAIAdapter, ResolvedAiConfig } from './types';\n\nconst DEFAULT_MODEL_BY_ROLE: Record<AiRole, string> = {\n    lead_analysis: 'gemini-flash-latest',\n    viability: 'gemini-2.5-flash',\n    company_analysis: 'gemini-2.5-flash',\n};\n\n/**\n * Returns resolved config and adapter for the given role.\n * Uses DB (AiProviderConfig no painel admin) first; se n√£o houver config para o role,\n * viability usa o mesmo config de lead_analysis (mesmo provedor/modelo da busca).\n * Sen√£o fallback env (GEMINI_API_KEY).\n */\nexport async function resolveAiForRole(role: AiRole): Promise<{ config: ResolvedAiConfig; adapter: IAIAdapter }> {\n    let fromDb = await getAiConfigFromDb(role);\n    if (!fromDb && (role === 'viability' || role === 'company_analysis')) {\n        fromDb = await getAiConfigFromDb(role === 'company_analysis' ? 'viability' : 'lead_analysis');\n    }\n    if (fromDb) {\n        const adapter = createAdapter(fromDb.provider, fromDb.model, fromDb.apiKey, fromDb.accountId);\n        return { config: { provider: fromDb.provider, model: fromDb.model, apiKey: fromDb.apiKey }, adapter };\n    }\n\n    const apiKey = process.env.GEMINI_API_KEY;\n    if (!apiKey) throw new Error(`No AI config for role \"${role}\" and GEMINI_API_KEY not set`);\n    const model = DEFAULT_MODEL_BY_ROLE[role];\n    const adapter = createGeminiAdapter(apiKey, model);\n    return {\n        config: { provider: 'GEMINI', model, apiKey },\n        adapter,\n    };\n}\n\n/**\n * Single entry point for completion: resolve by role and run.\n */\nexport async function generateCompletionForRole(\n    role: AiRole,\n    options: CompletionOptions\n): Promise<CompletionResult> {\n    const { adapter } = await resolveAiForRole(role);\n    return adapter.generateCompletion(options);\n}\n\ninterface DbConfig {\n    provider: AiProviderType;\n    model: string;\n    apiKey: string;\n    accountId?: string;\n}\n\nconst ROLE_TO_PRISMA: Record<AiRole, 'LEAD_ANALYSIS' | 'VIABILITY' | 'COMPANY_ANALYSIS'> = {\n    lead_analysis: 'LEAD_ANALYSIS',\n    viability: 'VIABILITY',\n    company_analysis: 'COMPANY_ANALYSIS',\n};\n\nasync function getAiConfigFromDb(role: AiRole): Promise<DbConfig | null> {\n    try {\n        const { prisma } = await import('@/lib/prisma');\n        const { decryptApiKey } = await import('@/lib/ai/encrypt');\n        const prismaRole = ROLE_TO_PRISMA[role];\n        const row = await prisma.aiProviderConfig.findFirst({\n            where: { role: prismaRole, enabled: true },\n            orderBy: { updatedAt: 'desc' },\n        });\n        if (!row || !row.apiKeyEncrypted) return null;\n        const apiKey = decryptApiKey(row.apiKeyEncrypted);\n        return {\n            provider: row.provider as AiProviderType,\n            model: row.model,\n            apiKey,\n            accountId: row.cloudflareAccountId ?? undefined,\n        };\n    } catch {\n        return null;\n    }\n}\n\nfunction createAdapter(\n    provider: AiProviderType,\n    model: string,\n    apiKey: string,\n    accountId?: string\n): IAIAdapter {\n    switch (provider) {\n        case 'GEMINI':\n            return createGeminiAdapter(apiKey, model);\n        case 'OPENAI':\n            return createOpenAIAdapter(apiKey, model);\n        case 'CLOUDFLARE':\n            return createCloudflareAdapter(apiKey, model, accountId);\n        default:\n            throw new Error(`Unknown AI provider: ${provider}`);\n    }\n}\n","/**\n * Serper.dev search adapter.\n * POST https://google.serper.dev/search with X-API-KEY header.\n */\n\nconst SERPER_URL = 'https://google.serper.dev/search';\n\nexport interface SerperResult {\n  title: string;\n  link: string;\n  snippet?: string;\n}\n\nexport async function searchSerper(\n  apiKey: string,\n  query: string,\n  num: number = 5\n): Promise<SerperResult[]> {\n  const res = await fetch(SERPER_URL, {\n    method: 'POST',\n    headers: {\n      'X-API-KEY': apiKey,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({ q: query, num }),\n  });\n  if (!res.ok) {\n    const errText = await res.text();\n    throw new Error(`Serper API error ${res.status}: ${errText}`);\n  }\n  const data = (await res.json()) as {\n    organic?: Array<{ title?: string; link?: string; snippet?: string }>;\n  };\n  const organic = data.organic ?? [];\n  return organic.slice(0, num).map((o) => ({\n    title: o.title ?? '',\n    link: o.link ?? '',\n    snippet: o.snippet,\n  }));\n}\n","/**\n * Resolves web search config by role and runs search queries.\n * Returns aggregated context text for injection into AI prompt.\n *\n * Results are grouped by source (Reclame Aqui, JusBrasil, CNPJ, etc.)\n * so the AI can clearly identify and cite each data source.\n */\n\nimport type { AiRole } from '@/lib/ai/types';\nimport { searchSerper } from './serper';\n\nconst ROLE_TO_PRISMA = {\n    lead_analysis: 'LEAD_ANALYSIS' as const,\n    viability: 'VIABILITY' as const,\n    company_analysis: 'COMPANY_ANALYSIS' as const,\n};\n\n/**\n * Fetch web search config for role (enabled, with key). Returns null if not configured.\n */\nasync function getWebSearchConfig(role: AiRole): Promise<{\n    provider: string;\n    apiKey: string;\n    maxResults: number;\n} | null> {\n    try {\n        const { prisma } = await import('@/lib/prisma');\n        const { decryptApiKey } = await import('@/lib/ai/encrypt');\n        const prismaRole = ROLE_TO_PRISMA[role];\n        const row = await prisma.webSearchConfig.findUnique({\n            where: { role: prismaRole },\n        });\n        if (!row || !row.enabled || !row.apiKeyEncrypted) return null;\n        const apiKey = decryptApiKey(row.apiKeyEncrypted);\n        return {\n            provider: row.provider,\n            apiKey,\n            maxResults: row.maxResults ?? 5,\n        };\n    } catch {\n        return null;\n    }\n}\n\nexport interface GetWebContextOptions {\n    workspaceId?: string;\n    userId?: string;\n}\n\ninterface SearchSection {\n    label: string;\n    emoji: string;\n    items: Array<{ title: string; link: string; snippet: string }>;\n}\n\n/**\n * Infer a human-readable section label + emoji from the query string.\n * This allows the AI to see exactly which data source each result came from.\n */\nfunction inferSectionLabel(query: string): { label: string; emoji: string } {\n    const q = query.toLowerCase();\n    if (q.includes('reclame aqui')) return { label: 'Reclame Aqui ‚Äî Reputa√ß√£o do Consumidor', emoji: 'üî¥' };\n    if (q.includes('jusbrasil')) return { label: 'JusBrasil ‚Äî Processos Judiciais', emoji: '‚öñÔ∏è' };\n    if (q.includes('cnpj')) return { label: 'CNPJ ‚Äî Dados Empresariais', emoji: 'üè¢' };\n    if (q.includes('instagram')) return { label: 'Redes sociais ‚Äî Instagram', emoji: 'üì±' };\n    if (q.includes('facebook')) return { label: 'Redes sociais ‚Äî Facebook', emoji: 'üì±' };\n    if (q.includes('linkedin')) return { label: 'Redes sociais ‚Äî LinkedIn', emoji: 'üì±' };\n    if (q.includes('avalia√ß√µes google') || q.includes('google reviews'))\n        return { label: 'Avalia√ß√µes Google', emoji: '‚≠ê' };\n    return { label: `Busca Web ‚Äî \"${query}\"`, emoji: 'üîç' };\n}\n\n/**\n * Format grouped sections into structured Markdown for injection into AI prompt.\n */\nfunction formatSections(sections: SearchSection[]): string {\n    const parts: string[] = [];\n    for (const section of sections) {\n        if (section.items.length === 0) continue;\n        parts.push(`### ${section.emoji} ${section.label}`);\n        for (const item of section.items) {\n            parts.push(`- **${item.title}** ‚Äî [${item.link}](${item.link})`);\n            if (item.snippet) {\n                parts.push(`  ${item.snippet}`);\n            }\n        }\n        parts.push(''); // blank line between sections\n    }\n    return parts.join('\\n');\n}\n\n/**\n * Run search for each query and return a single context block with labeled sections.\n * Each query generates its own section (Reclame Aqui, JusBrasil, CNPJ, etc.).\n * Returns empty string if no config or no results.\n */\nexport async function getWebContextForRole(\n    role: AiRole,\n    queries: string[],\n    options?: GetWebContextOptions\n): Promise<string> {\n    const config = await getWebSearchConfig(role);\n    if (!config || queries.length === 0) return '';\n\n    const sections: SearchSection[] = [];\n    let serperQueryCount = 0;\n\n    const maxQueries = role === 'company_analysis' ? 6 : 5;\n    for (const q of queries.slice(0, maxQueries)) {\n        if (!q.trim()) continue;\n        const { label, emoji } = inferSectionLabel(q);\n        const section: SearchSection = { label, emoji, items: [] };\n\n        try {\n            if (config.provider === 'SERPER') {\n                const items = await searchSerper(config.apiKey, q.trim(), Math.min(config.maxResults, 5));\n                serperQueryCount += 1;\n                for (const item of items) {\n                    section.items.push({\n                        title: item.title,\n                        link: item.link,\n                        snippet: item.snippet ?? '',\n                    });\n                }\n            }\n            // TAVILY: adapter not implemented yet; skip query\n        } catch {\n            // skip failed query\n        }\n\n        sections.push(section);\n    }\n\n    if (options?.workspaceId && serperQueryCount > 0) {\n        const { recordUsageEvent } = await import('@/lib/usage');\n        recordUsageEvent({\n            workspaceId: options.workspaceId,\n            userId: options.userId ?? undefined,\n            type: 'SERPER_REQUEST',\n            quantity: serperQueryCount,\n        });\n    }\n\n    const formattedSections = formatSections(sections);\n    if (!formattedSections.trim()) return '';\n\n    return `## üìä Contexto da Web (dados reais coletados ‚Äî use-os na an√°lise e cite as fontes)\\n\\n${formattedSections}`;\n}\n","/**\n * Geocoding via Google Geocoding API.\n * Resolves city/state/country to lat/lng for Places API locationBias.\n * Center = cidade; raio (escolhido no UI em km) √© aplicado a partir desse centro.\n * Uses GOOGLE_PLACES_API_KEY (same key can have Geocoding API enabled).\n */\n\nimport { fetchWithRetry } from '@/lib/fetch-http';\n\nconst GEOCODE_BASE = 'https://maps.googleapis.com/maps/api/geocode/json';\nconst GEOCODE_TIMEOUT_MS = 10000;\n\n/** Map country name/label to Google Geocoding API region code (biasing). */\nfunction getRegionCodeForCountry(country: string): string {\n  const normalized = country.trim().toLowerCase();\n  if (normalized.includes('brasil') || normalized === 'br') return 'br';\n  if (normalized.includes('argentina') || normalized === 'ar') return 'ar';\n  if (normalized.includes('m√©xico') || normalized.includes('mexico') || normalized === 'mx') return 'mx';\n  if (normalized.includes('estados unidos') || normalized.includes('united states') || normalized === 'us') return 'us';\n  if (normalized.includes('portugal') || normalized === 'pt') return 'pt';\n  if (normalized.includes('espanha') || normalized.includes('spain') || normalized === 'es') return 'es';\n  return 'br';\n}\n\nexport interface GeocodeResult {\n  latitude: number;\n  longitude: number;\n}\n\nexport async function geocodeAddress(\n  city: string,\n  state?: string | null,\n  country = 'Brasil'\n): Promise<GeocodeResult | null> {\n  const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n  if (!apiKey) return null;\n\n  const parts = [city.trim()];\n  if (state?.trim()) parts.push(state.trim());\n  parts.push(country);\n  const address = parts.join(', ');\n\n  const regionCode = getRegionCodeForCountry(country);\n  const url = new URL(GEOCODE_BASE);\n  url.searchParams.set('address', address);\n  url.searchParams.set('key', apiKey);\n  url.searchParams.set('region', regionCode);\n  url.searchParams.set('language', 'pt-BR');\n\n  const res = await fetchWithRetry(url.toString(), { method: 'GET' }, {\n    timeoutMs: GEOCODE_TIMEOUT_MS,\n    maxRetries: 2,\n  });\n  if (!res.ok) return null;\n  const data = (await res.json()) as {\n    status?: string;\n    results?: Array<{ geometry?: { location?: { lat?: number; lng?: number } } }>;\n  };\n  if (data.status !== 'OK' || !data.results?.[0]?.geometry?.location) return null;\n  const loc = data.results[0].geometry.location;\n  const lat = loc.lat;\n  const lng = loc.lng;\n  if (typeof lat !== 'number' || typeof lng !== 'number') return null;\n  return { latitude: lat, longitude: lng };\n}\n","/**\n * Estrutura do produto: 5 m√≥dulos de intelig√™ncia comercial.\n * Posicionamento: \"Intelig√™ncia para crescimento comercial local\"\n * Frase: \"Descubra onde vender, para quem vender e como abordar.\"\n */\n\nimport type { PlanType } from './billing-config';\n\n/** Planos */\nexport type ProductPlan = PlanType;\n\n/** M√≥dulos do produto (ordem de valor) */\nexport const MODULE_KEYS = [\n  'MAPEAMENTO',\n  'INTELIGENCIA_MERCADO',\n  'ANALISE_CONCORRENCIA',\n  'ANALISE_MINHA_EMPRESA',\n  'INTELIGENCIA_LEADS',\n  'ACAO_COMERCIAL',\n] as const;\n\nexport type ModuleKey = (typeof MODULE_KEYS)[number];\n\nexport interface ModuleDefinition {\n  key: ModuleKey;\n  name: string;\n  shortDescription: string;\n  /** Funcionalidades principais (para UI e documenta√ß√£o) */\n  features: string[];\n  /** Entregas (o que o cliente recebe) */\n  deliverables: string[];\n  /** Status no backend: j√° existe, parcial, planejado */\n  backendStatus: 'done' | 'partial' | 'planned';\n}\n\nexport const MODULES: Record<ModuleKey, ModuleDefinition> = {\n  MAPEAMENTO: {\n    key: 'MAPEAMENTO',\n    name: 'Mapeamento',\n    shortDescription: 'Buscar empresas por nicho e regi√£o',\n    features: [\n      'Buscar empresas por nicho',\n      'Filtrar por regi√£o',\n      'Filtros por site e telefone',\n      'Lista de resultados paginada',\n    ],\n    deliverables: ['Lista estruturada de empresas', 'Hist√≥rico de buscas'],\n    backendStatus: 'done', // busca + lista + hist√≥rico existem\n  },\n\n  INTELIGENCIA_MERCADO: {\n    key: 'INTELIGENCIA_MERCADO',\n    name: 'Intelig√™ncia de Mercado',\n    shortDescription: 'An√°lise de mercado local e tend√™ncias por regi√£o',\n    features: [\n      'Quantidade de empresas por segmento',\n      'Crescimento por categoria na regi√£o',\n      'Satura√ß√£o da regi√£o',\n      'Ticket m√©dio estimado',\n      'Score de maturidade digital',\n    ],\n    deliverables: [\n      'Relat√≥rio de mercado autom√°tico',\n      'An√°lise comparativa por bairro',\n      'Tend√™ncia local',\n    ],\n    backendStatus: 'partial',\n  },\n\n  ANALISE_CONCORRENCIA: {\n    key: 'ANALISE_CONCORRENCIA',\n    name: 'An√°lise de Concorr√™ncia',\n    shortDescription: 'Ranking e gaps vs concorrentes no raio',\n    features: [\n      'Quantos concorrentes no raio',\n      'Quem tem mais avalia√ß√µes',\n      'Presen√ßa digital (site, redes)',\n      'Quem n√£o tem site / redes',\n      'Ranking competitivo',\n    ],\n    deliverables: ['Score competitivo', 'Gap analysis', 'Lista de oportunidades'],\n    backendStatus: 'partial',\n  },\n\n  ANALISE_MINHA_EMPRESA: {\n    key: 'ANALISE_MINHA_EMPRESA',\n    name: 'An√°lise da minha empresa',\n    shortDescription: 'Diagn√≥stico da pr√≥pria empresa com Reclame Aqui, Google, redes sociais e IA',\n    features: [\n      'Reputa√ß√£o Reclame Aqui e reclama√ß√µes',\n      'Avalia√ß√µes Google (rating e reviews)',\n      'Presen√ßa em redes sociais (link + dados p√∫blicos)',\n      'Oportunidades e nicho sugerido',\n      'Modelo de neg√≥cio sugerido',\n    ],\n    deliverables: [\n      'Relat√≥rio de an√°lise da empresa',\n      'Se√ß√£o redes sociais',\n      'Recomenda√ß√µes e pr√≥ximos passos',\n    ],\n    backendStatus: 'done',\n  },\n\n  INTELIGENCIA_LEADS: {\n    key: 'INTELIGENCIA_LEADS',\n    name: 'Intelig√™ncia de Leads',\n    shortDescription: 'Score e classifica√ß√£o de potencial do lead',\n    features: [\n      'Score de investimento',\n      'Score de urg√™ncia',\n      'Classifica√ß√£o frio / morno / quente',\n      'Potencial financeiro',\n      'Probabilidade de compra',\n    ],\n    deliverables: ['Ranking de leads', 'Filtro por potencial', 'Sugest√£o de abordagem'],\n    backendStatus: 'partial', // score + an√°lise IA existe; scores adicionais planejados\n  },\n\n  ACAO_COMERCIAL: {\n    key: 'ACAO_COMERCIAL',\n    name: 'A√ß√£o Comercial',\n    shortDescription: 'Abordagem pronta para contato',\n    features: [\n      'Script de liga√ß√£o personalizado',\n      'E-mail pronto',\n      'Mensagem WhatsApp',\n      'Pitch adaptado ao nicho',\n      'Sequ√™ncia de follow-up',\n    ],\n    deliverables: ['Lead pronto para contato', 'Economia de tempo', 'Maior convers√£o'],\n    backendStatus: 'partial', // approach, firstContactMessage, suggestedWhatsAppMessage no LeadAnalysis\n  },\n};\n\n/** Planos e m√≥dulos que cada um desbloqueia (Starter ‚Üí Growth ‚Üí Scale) */\nexport const PLAN_MODULES: Record<ProductPlan, ModuleKey[]> = {\n  FREE: ['MAPEAMENTO', 'INTELIGENCIA_LEADS'],\n  BASIC: ['MAPEAMENTO', 'INTELIGENCIA_LEADS'],\n  PRO: [\n    'MAPEAMENTO',\n    'INTELIGENCIA_LEADS',\n    'ANALISE_CONCORRENCIA',\n    'ACAO_COMERCIAL',\n  ],\n  BUSINESS: [\n    'MAPEAMENTO',\n    'INTELIGENCIA_MERCADO',\n    'ANALISE_CONCORRENCIA',\n    'ANALISE_MINHA_EMPRESA',\n    'INTELIGENCIA_LEADS',\n    'ACAO_COMERCIAL',\n  ],\n  SCALE: [\n    'MAPEAMENTO',\n    'INTELIGENCIA_MERCADO',\n    'ANALISE_CONCORRENCIA',\n    'ANALISE_MINHA_EMPRESA',\n    'INTELIGENCIA_LEADS',\n    'ACAO_COMERCIAL',\n  ],\n};\n\n/** Retorna os m√≥dulos dispon√≠veis para um plano */\nexport function getModulesForPlan(plan: ProductPlan): ModuleKey[] {\n  return PLAN_MODULES[plan] ?? PLAN_MODULES.FREE;\n}\n\n/** Verifica se o plano tem acesso ao m√≥dulo */\nexport function planHasModule(plan: ProductPlan, moduleKey: ModuleKey): boolean {\n  return getModulesForPlan(plan).includes(moduleKey);\n}\n","import { prisma } from './prisma';\nimport { PlaceResult } from './google-places';\n\nexport async function syncLead(place: PlaceResult) {\n    try {\n        return await prisma.lead.upsert({\n            where: { placeId: place.id },\n            update: {\n                name: place.displayName.text,\n                address: place.formattedAddress,\n                phone: place.nationalPhoneNumber || place.internationalPhoneNumber,\n                website: place.websiteUri,\n                rating: place.rating,\n                reviewCount: place.userRatingCount,\n                types: place.types || [],\n                businessStatus: place.businessStatus,\n                lastSearchedAt: new Date(),\n            },\n            create: {\n                placeId: place.id,\n                name: place.displayName.text,\n                address: place.formattedAddress,\n                phone: place.nationalPhoneNumber || place.internationalPhoneNumber,\n                website: place.websiteUri,\n                rating: place.rating,\n                reviewCount: place.userRatingCount,\n                types: place.types || [],\n                businessStatus: place.businessStatus,\n            },\n        });\n    } catch (error) {\n        const { logger } = await import('@/lib/logger');\n        logger.error('Error syncing lead', { placeId: place.id, error: error instanceof Error ? error.message : 'Unknown' });\n        return null;\n    }\n}\n\nexport async function syncLeads(places: PlaceResult[]) {\n    return Promise.all(places.map(syncLead));\n}\n","import Redis from 'ioredis';\n\nlet redis: Redis | null = null;\n\nfunction getRedis(): Redis | null {\n    if (redis) return redis;\n    const url = process.env.REDIS_URL || 'redis://localhost:6379';\n    try {\n        redis = new Redis(url, {\n            maxRetriesPerRequest: 1,\n            retryStrategy: (times) => {\n                if (times > 2) return null;\n                return Math.min(times * 200, 1000);\n            },\n            lazyConnect: true,\n        });\n        redis.on('error', () => {\n            redis = null;\n        });\n        return redis;\n    } catch {\n        return null;\n    }\n}\n\nexport async function getCached<T>(key: string): Promise<T | null> {\n    try {\n        const client = getRedis();\n        if (!client) return null;\n        await client.connect().catch(() => { });\n        const data = await client.get(key);\n        if (!data) return null;\n        return JSON.parse(data) as T;\n    } catch {\n        return null;\n    }\n}\n\nexport async function setCached(key: string, value: unknown, ttlSeconds = 300): Promise<void> {\n    try {\n        const client = getRedis();\n        if (!client) return;\n        await client.connect().catch(() => { });\n        await client.set(key, JSON.stringify(value), 'EX', ttlSeconds);\n    } catch {\n        // silently fail ‚Äî cache is optional\n    }\n}\n","/**\n * Usage event recording for admin dashboard metrics.\n * Fire-and-forget: does not block the request; errors are logged only.\n */\n\nimport { prisma } from '@/lib/prisma';\nimport type { UsageEventType } from '@prisma/client';\n\nexport interface RecordUsageOptions {\n  workspaceId: string;\n  userId?: string | null;\n  type: UsageEventType;\n  quantity?: number;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface WorkspaceUsage {\n  googlePlacesSearch: number;\n  googlePlacesDetails: number;\n  serperRequests: number;\n  aiInputTokens: number;\n  aiOutputTokens: number;\n}\n\n/**\n * Record a usage event (Google Places, Serper, AI tokens).\n * Runs in background; does not throw.\n */\nexport function recordUsageEvent(options: RecordUsageOptions): void {\n  const { workspaceId, userId, type, quantity = 1, metadata } = options;\n  void prisma.usageEvent\n    .create({\n      data: {\n        workspaceId,\n        userId: userId ?? undefined,\n        type,\n        quantity,\n        metadata: metadata ? (metadata as object) : undefined,\n      },\n    })\n    .catch((err) => {\n      import('@/lib/logger').then(({ logger }) =>\n        logger.warn('Usage event record failed', { workspaceId, type, error: err instanceof Error ? err.message : 'Unknown' })\n      );\n    });\n}\n\n/**\n * Get aggregated usage for one or more workspaces.\n */\nexport async function getWorkspaceUsage(workspaceIds: string[]): Promise<Map<string, WorkspaceUsage>> {\n  if (workspaceIds.length === 0) return new Map();\n  const defaultUsage: WorkspaceUsage = {\n    googlePlacesSearch: 0,\n    googlePlacesDetails: 0,\n    serperRequests: 0,\n    aiInputTokens: 0,\n    aiOutputTokens: 0,\n  };\n  const map = new Map<string, WorkspaceUsage>(workspaceIds.map((id) => [id, { ...defaultUsage }]));\n\n  const nonAi = await prisma.usageEvent.groupBy({\n    by: ['workspaceId', 'type'],\n    where: { workspaceId: { in: workspaceIds }, type: { not: 'AI_TOKENS' } },\n    _sum: { quantity: true },\n  });\n  for (const row of nonAi) {\n    const u = map.get(row.workspaceId)!;\n    const sum = row._sum.quantity ?? 0;\n    if (row.type === 'GOOGLE_PLACES_SEARCH') u.googlePlacesSearch = sum;\n    else if (row.type === 'GOOGLE_PLACES_DETAILS') u.googlePlacesDetails = sum;\n    else if (row.type === 'SERPER_REQUEST') u.serperRequests = sum;\n  }\n\n  const aiEvents = await prisma.usageEvent.findMany({\n    where: { workspaceId: { in: workspaceIds }, type: 'AI_TOKENS' },\n    select: { workspaceId: true, metadata: true },\n  });\n  for (const e of aiEvents) {\n    const u = map.get(e.workspaceId)!;\n    const m = e.metadata as { inputTokens?: number; outputTokens?: number } | null;\n    if (m) {\n      u.aiInputTokens += Number(m.inputTokens) || 0;\n      u.aiOutputTokens += Number(m.outputTokens) || 0;\n    }\n  }\n  return map;\n}\n","/**\n * HTTP fetch with timeout and optional retry on 429/5xx.\n * Evita requisi√ß√µes travadas e trata rate limit/erros transit√≥rios.\n */\n\nconst DEFAULT_TIMEOUT_MS = 15000;\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_INITIAL_BACKOFF_MS = 1000;\n\nfunction sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport interface FetchWithRetryOptions {\n    timeoutMs?: number;\n    maxRetries?: number;\n    initialBackoffMs?: number;\n    /** Retry when response status is in this set (e.g. 429, 503). */\n    retryStatuses?: (status: number) => boolean;\n}\n\nconst defaultRetryStatuses = (status: number): boolean =>\n    status === 429 || (status >= 500 && status < 600);\n\n/**\n * Fetch with timeout (AbortController). Optional retry with exponential backoff on 429/5xx.\n */\nexport async function fetchWithRetry(\n    url: string,\n    init: RequestInit,\n    options: FetchWithRetryOptions = {}\n): Promise<Response> {\n    const {\n        timeoutMs = DEFAULT_TIMEOUT_MS,\n        maxRetries = DEFAULT_MAX_RETRIES,\n        initialBackoffMs = DEFAULT_INITIAL_BACKOFF_MS,\n        retryStatuses = defaultRetryStatuses,\n    } = options;\n\n    let lastRes: Response | null = null;\n    let lastErr: Error | null = null;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n        const mergedInit: RequestInit = {\n            ...init,\n            signal: controller.signal,\n        };\n\n        try {\n            const res = await fetch(url, mergedInit);\n            clearTimeout(timeoutId);\n            lastRes = res;\n            if (attempt < maxRetries && retryStatuses(res.status)) {\n                const backoff = initialBackoffMs * Math.pow(2, attempt);\n                await sleep(backoff);\n                continue;\n            }\n            return res;\n        } catch (err) {\n            clearTimeout(timeoutId);\n            lastErr = err instanceof Error ? err : new Error(String(err));\n            if (attempt < maxRetries) {\n                const backoff = initialBackoffMs * Math.pow(2, attempt);\n                await sleep(backoff);\n                continue;\n            }\n            throw lastErr;\n        }\n    }\n\n    if (lastRes) return lastRes;\n    throw lastErr ?? new Error('fetchWithRetry failed');\n}\n","import { fetchWithRetry } from '@/lib/fetch-http';\n\nconst PLACES_API_BASE = 'https://places.googleapis.com/v1/places';\n\n/** Places API searchText max pageSize (doc: values above 20 are set to 20). */\nexport const PLACES_PAGE_SIZE_MAX = 20;\nconst PLACES_REQUEST_TIMEOUT_MS = 15000;\n/** Delay before using nextPageToken (API may reject or repeat if immediate). */\nconst NEXT_PAGE_TOKEN_DELAY_MS = 400;\n\nexport interface PlaceResult {\n    id: string;\n    displayName: { text: string; languageCode: string };\n    formattedAddress?: string;\n    nationalPhoneNumber?: string;\n    internationalPhoneNumber?: string;\n    websiteUri?: string;\n    googleMapsUri?: string;\n    rating?: number;\n    userRatingCount?: number;\n    types?: string[];\n    businessStatus?: string;\n    currentOpeningHours?: {\n        openNow?: boolean;\n        weekdayDescriptions?: string[];\n    };\n    reviews?: Array<{\n        name: string;\n        rating: number;\n        text: { text: string };\n        authorAttribution: { displayName: string };\n        relativePublishTimeDescription: string;\n    }>;\n    primaryType?: string;\n    primaryTypeDisplayName?: { text: string };\n}\n\nexport interface TextSearchResponse {\n    places: PlaceResult[];\n    nextPageToken?: string;\n}\n\n/** locationBias circle: center = cidade (geocodificada), radius = raio a partir da cidade. API exige radius em metros (max 50000). UI usa km. */\nexport interface LocationBiasCircle {\n    center: { latitude: number; longitude: number };\n    /** Raio em metros (UI envia km; converter antes de chamar a API). */\n    radius: number;\n}\n\nexport interface TextSearchParams {\n    textQuery: string;\n    includedType?: string;\n    pageSize?: number;\n    pageToken?: string;\n    languageCode?: string;\n    regionCode?: string;\n    /** Bias results to this region (Places API doc: locationBias.circle). */\n    locationBias?: LocationBiasCircle;\n}\n\nconst SEARCH_FIELD_MASK = [\n    'places.id',\n    'places.displayName',\n    'places.formattedAddress',\n    'places.nationalPhoneNumber',\n    'places.internationalPhoneNumber',\n    'places.websiteUri',\n    'places.googleMapsUri',\n    'places.rating',\n    'places.userRatingCount',\n    'places.types',\n    'places.businessStatus',\n    'places.primaryType',\n    'places.primaryTypeDisplayName',\n    'nextPageToken',\n].join(',');\n\nconst DETAILS_FIELD_MASK = [\n    'id',\n    'displayName',\n    'formattedAddress',\n    'nationalPhoneNumber',\n    'internationalPhoneNumber',\n    'websiteUri',\n    'googleMapsUri',\n    'rating',\n    'userRatingCount',\n    'types',\n    'businessStatus',\n    'currentOpeningHours',\n    'reviews',\n    'primaryType',\n    'primaryTypeDisplayName',\n].join(',');\n\n/**\n * In-memory cache of original request bodies keyed by nextPageToken.\n * Google Places API requires pagination requests to use identical params.\n * We store the original body (without pageToken) so we can replay it exactly.\n * TTL: entries auto-expire after 10 minutes via a simple cleanup.\n */\nconst pageTokenBodyCache = new Map<string, { body: Record<string, unknown>; ts: number }>();\nconst PAGE_TOKEN_CACHE_TTL_MS = 10 * 60 * 1000;\n\nfunction cleanupPageTokenCache() {\n    const now = Date.now();\n    for (const [key, val] of pageTokenBodyCache) {\n        if (now - val.ts > PAGE_TOKEN_CACHE_TTL_MS) pageTokenBodyCache.delete(key);\n    }\n}\n\nexport async function textSearch(params: TextSearchParams): Promise<TextSearchResponse> {\n    const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n    if (!apiKey) throw new Error('GOOGLE_PLACES_API_KEY not configured');\n\n    const pageSizeClamped = Math.min(\n        PLACES_PAGE_SIZE_MAX,\n        Math.max(1, params.pageSize ?? PLACES_PAGE_SIZE_MAX)\n    );\n\n    let body: Record<string, unknown>;\n\n    if (params.pageToken) {\n        // Pagination: replay the EXACT original body + pageToken\n        const cached = pageTokenBodyCache.get(params.pageToken);\n        if (cached) {\n            body = { ...cached.body, pageToken: params.pageToken };\n        } else {\n            // Fallback: build body with only textQuery + pageToken (no extra filters)\n            body = {\n                textQuery: params.textQuery,\n                pageSize: pageSizeClamped,\n                languageCode: params.languageCode || 'pt-BR',\n                regionCode: params.regionCode || 'BR',\n                pageToken: params.pageToken,\n            };\n        }\n    } else {\n        // Initial request: build full body with all filters\n        body = {\n            textQuery: params.textQuery,\n            pageSize: pageSizeClamped,\n            languageCode: params.languageCode || 'pt-BR',\n            regionCode: params.regionCode || 'BR',\n        };\n        if (params.includedType) body.includedType = params.includedType;\n        if (params.locationBias?.center && params.locationBias?.radius != null) {\n            const radius = Math.min(50000, Math.max(0, params.locationBias.radius));\n            body.locationBias = {\n                circle: {\n                    center: {\n                        latitude: params.locationBias.center.latitude,\n                        longitude: params.locationBias.center.longitude,\n                    },\n                    radius,\n                },\n            };\n        }\n    }\n\n    const res = await fetchWithRetry(\n        `${PLACES_API_BASE}:searchText`,\n        {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Goog-Api-Key': apiKey,\n                'X-Goog-FieldMask': SEARCH_FIELD_MASK,\n            },\n            body: JSON.stringify(body),\n        },\n        { timeoutMs: PLACES_REQUEST_TIMEOUT_MS, maxRetries: 3 }\n    );\n\n    if (!res.ok) {\n        const err = await res.text();\n        throw new Error(`Places API error (${res.status}): ${err}`);\n    }\n\n    const data = await res.json();\n\n    // Cache the original body (without pageToken) for future pagination\n    if (data.nextPageToken) {\n        const bodyWithoutToken = { ...body };\n        delete bodyWithoutToken.pageToken;\n        pageTokenBodyCache.set(data.nextPageToken, { body: bodyWithoutToken, ts: Date.now() });\n        // Periodic cleanup\n        if (pageTokenBodyCache.size > 50) cleanupPageTokenCache();\n    }\n\n    return {\n        places: data.places || [],\n        nextPageToken: data.nextPageToken,\n    };\n}\n\n/** Fetch multiple pages of search results up to maxPlaces (Places API returns max 20 per page). */\nexport async function textSearchAllPages(\n    params: TextSearchParams & { maxPlaces: number }\n): Promise<{ places: PlaceResult[] }> {\n    const { maxPlaces, ...searchParams } = params;\n    const cap = Math.max(1, Math.min(maxPlaces, 60));\n    const all: PlaceResult[] = [];\n    let pageToken: string | undefined;\n\n    while (all.length < cap) {\n        const res = await textSearch({\n            ...searchParams,\n            pageSize: Math.min(PLACES_PAGE_SIZE_MAX, cap - all.length),\n            pageToken,\n            // locationBias only on first page; subsequent pages use pageToken\n            locationBias: pageToken ? undefined : searchParams.locationBias,\n        });\n        const batch = res.places ?? [];\n        all.push(...batch);\n        if (batch.length === 0 || !res.nextPageToken) break;\n        if (all.length >= cap) break;\n        pageToken = res.nextPageToken;\n        await new Promise((r) => setTimeout(r, NEXT_PAGE_TOKEN_DELAY_MS));\n    }\n\n    return { places: all.slice(0, cap) };\n}\n\nexport async function getPlaceDetails(placeId: string): Promise<PlaceResult> {\n    const apiKey = process.env.GOOGLE_PLACES_API_KEY;\n    if (!apiKey) throw new Error('GOOGLE_PLACES_API_KEY not configured');\n\n    const res = await fetchWithRetry(\n        `${PLACES_API_BASE}/${placeId}`,\n        {\n            method: 'GET',\n            headers: {\n                'X-Goog-Api-Key': apiKey,\n                'X-Goog-FieldMask': DETAILS_FIELD_MASK,\n            },\n        },\n        { timeoutMs: PLACES_REQUEST_TIMEOUT_MS, maxRetries: 2 }\n    );\n\n    if (!res.ok) {\n        const err = await res.text();\n        throw new Error(`Place Details error (${res.status}): ${err}`);\n    }\n\n    return await res.json();\n}\n","/**\n * Search module ‚Äî application layer (use-case).\n * Orchestrates cache, DB, external API, history and usage.\n * Route (api) only validates, authenticates and calls runSearch.\n */\n\nimport { prisma } from '@/lib/prisma';\nimport { textSearch, textSearchAllPages, PLACES_PAGE_SIZE_MAX } from '@/lib/google-places';\nimport { geocodeAddress } from '@/lib/geocode';\nimport { getCached } from '@/lib/redis';\nimport { syncLeads } from '@/lib/db-sync';\nimport { logger } from '@/lib/logger';\nimport { recordUsageEvent } from '@/lib/usage';\nimport type { SearchInput } from '@/lib/validations/schemas';\nimport type { SearchResult, PlaceLike } from '../domain/types';\n\n/** UI sempre em km; convers√£o para metros s√≥ na chamada √† API (locationBias.radius). */\nconst RADIUS_KM_TO_M = 1000;\nconst DEFAULT_LOCATION_RADIUS_KM = 15;\n/** Places API locationBias circle max radius (meters) = 50km */\nconst MAX_LOCATION_RADIUS_M = 50000;\n/** Delay antes de usar nextPageToken (API pode rejeitar ou repetir se imediato). */\nconst NEXT_PAGE_TOKEN_DELAY_MS = 400;\n\nexport class SearchHttpError extends Error {\n    constructor(\n        public readonly status: number,\n        public readonly body: Record<string, unknown>\n    ) {\n        super(typeof body.error === 'string' ? body.error : 'Request failed');\n        this.name = 'SearchHttpError';\n    }\n}\n\nfunction filterPlaces<T extends PlaceLike>(\n    places: T[],\n    hasWebsite?: string | null,\n    hasPhone?: string | null\n): T[] {\n    return places.filter((place): place is T => {\n        const website = place.websiteUri || place.website;\n        const phone = place.nationalPhoneNumber || place.internationalPhoneNumber || place.phone;\n        if (hasWebsite === 'yes' && !website) return false;\n        if (hasWebsite === 'no' && website) return false;\n        if (hasPhone === 'yes' && !phone) return false;\n        if (hasPhone === 'no' && phone) return false;\n        return true;\n    });\n}\n\nexport async function runSearch(input: SearchInput, userId: string): Promise<SearchResult> {\n    const { textQuery, includedType, pageSize, pageToken, hasWebsite, hasPhone, city, state, country, radiusKm } = input;\n    const effectivePageSize = Math.min(PLACES_PAGE_SIZE_MAX, Math.max(1, pageSize ?? PLACES_PAGE_SIZE_MAX));\n    const filtersPayload = {\n        includedType: includedType ?? null,\n        hasWebsite: hasWebsite ?? null,\n        hasPhone: hasPhone ?? null,\n    };\n\n    logger.info('Search request', {\n        textQuery,\n        includedType: includedType ?? null,\n        effectivePageSize,\n        hasWebsite: hasWebsite ?? null,\n        hasPhone: hasPhone ?? null,\n    });\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n            onboardingCompletedAt: true,\n            workspaces: { include: { workspace: true }, take: 1 },\n        },\n    });\n\n    if (!user || user.workspaces.length === 0) {\n        throw new SearchHttpError(404, { error: 'Workspace not found' });\n    }\n\n    if (user.onboardingCompletedAt == null) {\n        throw new SearchHttpError(403, {\n            error: 'Complete onboarding before searching',\n            code: 'REQUIRES_ONBOARDING',\n        });\n    }\n\n    const activeWorkspace = user.workspaces[0].workspace;\n\n    if (activeWorkspace.leadsUsed >= activeWorkspace.leadsLimit) {\n        throw new SearchHttpError(403, {\n            error: 'Limit reached',\n            code: 'LIMIT_EXCEEDED',\n            limit: activeWorkspace.leadsLimit,\n            used: activeWorkspace.leadsUsed,\n        });\n    }\n\n    const saveHistory = async (resultsCount: number, places?: unknown[]): Promise<void> => {\n        await prisma.searchHistory\n            .create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectivePageSize,\n                    filters: filtersPayload,\n                    resultsCount,\n                    resultsData: places ? JSON.parse(JSON.stringify(places)) : undefined,\n                },\n            })\n            .catch((err) =>\n                logger.error('SearchHistory create error', {\n                    error: err instanceof Error ? err.message : 'Unknown',\n                })\n            );\n    };\n\n    if (!pageToken) {\n        const cacheKey = `search:${textQuery}:${includedType || ''}:${effectivePageSize}:${hasWebsite || 'any'}:${hasPhone || 'any'}`;\n        const cached = await getCached<{ places: unknown[]; nextPageToken?: string }>(cacheKey);\n        const cachedCount = cached?.places?.length ?? 0;\n        const minAcceptableFromCache = Math.min(5, effectivePageSize);\n        if (cachedCount >= minAcceptableFromCache) {\n            logger.info('Search: cache hit', { cachedCount });\n            await saveHistory(cachedCount, cached!.places);\n            return { ...cached!, fromCache: true };\n        }\n        if (cachedCount > 0) {\n            logger.info('Search: cache skipped (below minimum)', { cachedCount, minAcceptableFromCache });\n        }\n\n        const dbLeads = await prisma.lead.findMany({\n            where: {\n                OR: [\n                    { name: { contains: textQuery, mode: 'insensitive' } },\n                    { address: { contains: textQuery, mode: 'insensitive' } },\n                ],\n            },\n            take: 100,\n            orderBy: { lastSearchedAt: 'desc' },\n        });\n\n        if (dbLeads.length >= 10) {\n            const mapped = dbLeads.map((l) => ({\n                id: l.placeId,\n                displayName: { text: l.name },\n                formattedAddress: l.address,\n                nationalPhoneNumber: l.phone,\n                websiteUri: l.website,\n                rating: l.rating,\n                userRatingCount: l.reviewCount,\n                types: l.types,\n                businessStatus: l.businessStatus,\n            }));\n\n            const filtered = filterPlaces(mapped, hasWebsite, hasPhone);\n            const slice = filtered.slice(0, effectivePageSize);\n            if (slice.length >= 5) {\n                logger.info('Search: local DB used', { dbTotal: dbLeads.length, afterFilter: filtered.length, returned: slice.length });\n                await saveHistory(slice.length, slice);\n                return { places: slice, fromLocalDb: true };\n            }\n        }\n        logger.info('Search: local DB skip', { dbLeadsCount: dbLeads.length });\n    }\n\n    let locationBias: { center: { latitude: number; longitude: number }; radius: number } | undefined;\n    const cityTrim = city?.trim();\n    if (cityTrim && !pageToken) {\n        const coords = await geocodeAddress(cityTrim, state ?? null, country ?? 'Brasil');\n        if (coords) {\n            const radiusKmNum = radiusKm ?? DEFAULT_LOCATION_RADIUS_KM;\n            const radiusM = Math.min(\n                MAX_LOCATION_RADIUS_M,\n                Math.round(radiusKmNum * RADIUS_KM_TO_M) || Math.round(DEFAULT_LOCATION_RADIUS_KM * RADIUS_KM_TO_M)\n            );\n            locationBias = { center: coords, radius: radiusM };\n            logger.info('Search: locationBias applied', { city: cityTrim, radiusKm: radiusKmNum, radiusM });\n        } else {\n            logger.info('Search: geocode failed, no locationBias', { city: cityTrim });\n        }\n    }\n\n    if (pageToken) {\n        await new Promise((r) => setTimeout(r, NEXT_PAGE_TOKEN_DELAY_MS));\n    }\n\n    logger.info('Search: calling Google Places API', { textQuery, includedType: includedType ?? null, hasLocationBias: !!locationBias, hasPageToken: !!pageToken });\n    const result = await textSearch({\n        textQuery,\n        includedType: includedType || undefined,\n        pageSize: effectivePageSize,\n        pageToken: pageToken || undefined,\n        locationBias,\n    });\n\n    const rawCount = result.places?.length ?? 0;\n    if (result.places) {\n        result.places = filterPlaces(result.places, hasWebsite, hasPhone).slice(0, effectivePageSize);\n    }\n    const finalCount = result.places?.length ?? 0;\n    logger.info('Search: Google Places response', { rawCount, afterFilter: finalCount, hasWebsite: hasWebsite ?? null, hasPhone: hasPhone ?? null });\n\n    if (result.places && result.places.length > 0) {\n        recordUsageEvent({\n            workspaceId: activeWorkspace.id,\n            userId,\n            type: 'GOOGLE_PLACES_SEARCH',\n            quantity: 1,\n        });\n\n        syncLeads(result.places).catch((err) =>\n            logger.error('Background sync error', {\n                error: err instanceof Error ? err.message : 'Unknown',\n            })\n        );\n\n        await prisma.$transaction([\n            prisma.workspace.update({\n                where: { id: activeWorkspace.id },\n                data: { leadsUsed: { increment: 1 } },\n            }),\n            prisma.searchHistory.create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectivePageSize,\n                    filters: filtersPayload,\n                    resultsCount: result.places.length,\n                    resultsData: JSON.parse(JSON.stringify(result.places)),\n                },\n            }),\n        ]);\n    }\n\n    logger.info('Search: result', { resultCount: finalCount });\n    return result;\n}\n\n/** Max places to fetch in one runSearchAllPages call (intelligence modules). */\nexport const SEARCH_ALL_PAGES_MAX_PLACES = 60;\n\nexport interface SearchAllPagesResult {\n    places: unknown[];\n    totalFetched: number;\n}\n\n/**\n * Fetch multiple pages of search results (up to maxPlaces) for intelligence modules.\n * Uses a single usage credit regardless of how many API pages are fetched.\n */\nexport async function runSearchAllPages(\n    input: SearchInput,\n    userId: string,\n    maxPlaces: number\n): Promise<SearchAllPagesResult> {\n    const { textQuery, includedType, hasWebsite, hasPhone, city, state, country, radiusKm } = input;\n    const effectiveMax = Math.min(maxPlaces, SEARCH_ALL_PAGES_MAX_PLACES);\n\n    const user = await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n            onboardingCompletedAt: true,\n            workspaces: { include: { workspace: true }, take: 1 },\n        },\n    });\n\n    if (!user || user.workspaces.length === 0) {\n        throw new SearchHttpError(404, { error: 'Workspace not found' });\n    }\n\n    if (user.onboardingCompletedAt == null) {\n        throw new SearchHttpError(403, {\n            error: 'Complete onboarding before searching',\n            code: 'REQUIRES_ONBOARDING',\n        });\n    }\n\n    const activeWorkspace = user.workspaces[0].workspace;\n\n    if (activeWorkspace.leadsUsed >= activeWorkspace.leadsLimit) {\n        throw new SearchHttpError(403, {\n            error: 'Limit reached',\n            code: 'LIMIT_EXCEEDED',\n            limit: activeWorkspace.leadsLimit,\n            used: activeWorkspace.leadsUsed,\n        });\n    }\n\n    let locationBias: { center: { latitude: number; longitude: number }; radius: number } | undefined;\n    const cityTrim = city?.trim();\n    if (cityTrim) {\n        const coords = await geocodeAddress(cityTrim, state ?? null, country ?? 'Brasil');\n        if (coords) {\n            const radiusKmNum = radiusKm ?? DEFAULT_LOCATION_RADIUS_KM;\n            const radiusM = Math.min(\n                MAX_LOCATION_RADIUS_M,\n                Math.round(radiusKmNum * RADIUS_KM_TO_M) || Math.round(DEFAULT_LOCATION_RADIUS_KM * RADIUS_KM_TO_M)\n            );\n            locationBias = { center: coords, radius: radiusM };\n            logger.info('SearchAllPages: locationBias applied', { city: cityTrim, radiusM });\n        }\n    }\n\n    logger.info('SearchAllPages: fetching up to N places', { textQuery, effectiveMax });\n    const { places: rawPlaces } = await textSearchAllPages({\n        textQuery,\n        includedType: includedType || undefined,\n        locationBias,\n        maxPlaces: effectiveMax,\n    });\n\n    const places = filterPlaces(rawPlaces, hasWebsite, hasPhone).slice(0, effectiveMax);\n    const totalFetched = places.length;\n\n    if (places.length > 0) {\n        recordUsageEvent({\n            workspaceId: activeWorkspace.id,\n            userId,\n            type: 'GOOGLE_PLACES_SEARCH',\n            quantity: 1,\n        });\n\n        syncLeads(places).catch((err) =>\n            logger.error('Background sync error', {\n                error: err instanceof Error ? err.message : 'Unknown',\n            })\n        );\n\n        const filtersPayload = {\n            includedType: includedType ?? null,\n            hasWebsite: hasWebsite ?? null,\n            hasPhone: hasPhone ?? null,\n        };\n\n        await prisma.$transaction([\n            prisma.workspace.update({\n                where: { id: activeWorkspace.id },\n                data: { leadsUsed: { increment: 1 } },\n            }),\n            prisma.searchHistory.create({\n                data: {\n                    workspaceId: activeWorkspace.id,\n                    userId,\n                    textQuery,\n                    pageSize: effectiveMax,\n                    filters: filtersPayload,\n                    resultsCount: totalFetched,\n                    resultsData: JSON.parse(JSON.stringify(places)),\n                },\n            }),\n        ]);\n    }\n\n    logger.info('SearchAllPages: result', { totalFetched });\n    return { places, totalFetched };\n}\n"],"names":[],"mappings":"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"}